<!DOCTYPE html>
<html lang="en">
<head>
    <title>3D Demo</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&display=swap');
        a {
            color: #f00;
        }
        #ui-panel, #ui-panel label, #ui-panel span, #ui-panel button {
            font-family: 'Noto Sans TC', Arial, sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #fff;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            z-index: 10;
        }
        .ui-section {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #555;
            border-radius: 5px;
        }
        .ui-section h3 {
            margin-top: 0;
            color: #fff;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.167.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.167.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, renderer, camera, floor, playerGroup, orbitControls, clock, dirLight;
        let cameraDistance = 10;
        let cameraFov = 80;
        let renderDistance = 100;
        const keys = { w: false, a: false, s: false, d: false, '1': false };
        let uiPanel, toggleBtn;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let targetPosition = null;
        let isSkillMode = false;
        let isSkillMoving = false;
        let skillSpeed = 240;
        let skillCircle;
        let skillRadius = 5;
        let ease = new THREE.Vector3();
        let position = new THREE.Vector3(0, 1, 0);
        let up = new THREE.Vector3(0, 1, 0);
        let rotate = new THREE.Quaternion();
        let currentMoveSpeed = 80;

        const defaults = {
            moveSpeed: 80,
            skillSpeed: 240,
            skillRadius: 5,
            cameraDistance: 10,
            cameraFov: 80,
            circleRadius: 40,
            renderDistance: 100
        };

        const settings = {
            moveSpeed: defaults.moveSpeed,
            circleRadius: defaults.circleRadius,
            rotateSpeed: 0.05
        };

        init();
        animate();

        function init() {
            const container = document.getElementById('container');
            container.style.position = 'absolute';
            container.style.top = '0';
            container.style.left = '0';
            container.style.width = '100%';
            container.style.height = '100%';
            document.body.style.margin = '0';
            document.body.style.overflow = 'hidden';

            // Load settings from localStorage
            const saved = localStorage.getItem('gameSettings');
            if (saved) {
                const parsed = JSON.parse(saved);
                settings.moveSpeed = parsed.moveSpeed || defaults.moveSpeed;
                skillSpeed = parsed.skillSpeed || defaults.skillSpeed;
                skillRadius = parsed.skillRadius || defaults.skillRadius;
                cameraDistance = parsed.cameraDistance || defaults.cameraDistance;
                cameraFov = parsed.cameraFov || defaults.cameraFov;
                settings.circleRadius = parsed.circleRadius || defaults.circleRadius;
                renderDistance = parsed.renderDistance || defaults.renderDistance;
            }

            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x5e5d5d);

            // Camera setup
            camera = new THREE.PerspectiveCamera(cameraFov, window.innerWidth / window.innerHeight, 0.1, renderDistance);
            camera.position.set(0, 2.5, -cameraDistance);

            // Clock
            clock = new THREE.Clock();

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(0, 10, 0);
            dirLight.castShadow = true;
            updateShadowCamera();
            dirLight.shadow.mapSize.set(2048, 2048);
            scene.add(dirLight);
            scene.add(dirLight.target);

            // Floor (circle)
            const floorGeometry = new THREE.CircleGeometry(settings.circleRadius, 32);
            const floorMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, side: THREE.DoubleSide });
            floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Reference points (8 radial lines, offset by 22.5Â°)
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
            for (let i = 0; i < 8; i++) {
                const angle = (i * Math.PI / 4) + (Math.PI / 8);
                const points = [
                    new THREE.Vector3(0, 0.01, 0),
                    new THREE.Vector3(Math.cos(angle) * settings.circleRadius, 0.01, Math.sin(angle) * settings.circleRadius)
                ];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, lineMaterial);
                scene.add(line);
            }

            // 4 Cylinders
            const cylinderGeometry = new THREE.CylinderGeometry(0.2, 0.2, 2, 32);
            const northCylinder = new THREE.Mesh(cylinderGeometry, new THREE.MeshStandardMaterial({ color: 0xFF6600 }));
            northCylinder.position.set(0, 1, settings.circleRadius + 0.5);
            northCylinder.castShadow = true;
            scene.add(northCylinder);
            const eastCylinder = new THREE.Mesh(cylinderGeometry, new THREE.MeshStandardMaterial({ color: 0xffffff }));
            eastCylinder.position.set(settings.circleRadius + 0.5, 1, 0);
            eastCylinder.castShadow = true;
            scene.add(eastCylinder);
            const southCylinder = new THREE.Mesh(cylinderGeometry, new THREE.MeshStandardMaterial({ color: 0xffffff }));
            southCylinder.position.set(0, 1, -(settings.circleRadius + 0.5));
            southCylinder.castShadow = true;
            scene.add(southCylinder);
            const westCylinder = new THREE.Mesh(cylinderGeometry, new THREE.MeshStandardMaterial({ color: 0xffffff }));
            westCylinder.position.set(-(settings.circleRadius + 0.5), 1, 0);
            westCylinder.castShadow = true;
            scene.add(westCylinder);

            // Player group
            playerGroup = new THREE.Group();
            playerGroup.position.copy(position);
            scene.add(playerGroup);

            // Player sphere
            const playerGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            const playerMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
            const playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
            playerMesh.position.y = 1;
            playerMesh.castShadow = true;
            playerGroup.add(playerMesh);

            // Skill circle
            const skillGeometry = new THREE.CircleGeometry(skillRadius, 32);
            const skillMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
            skillCircle = new THREE.Mesh(skillGeometry, skillMaterial);
            skillCircle.rotation.x = -Math.PI / 2;
            skillCircle.position.y = 0.01;
            skillCircle.visible = false;
            scene.add(skillCircle);

            // OrbitControls
            orbitControls = new OrbitControls(camera, renderer.domElement);
            orbitControls.target.copy(position);
            orbitControls.enableDamping = false;
            orbitControls.enablePan = false;
            orbitControls.maxPolarAngle = Math.PI / 2 - 0.05;
            orbitControls.mouseButtons = {
                LEFT: null,
                MIDDLE: null,
                RIGHT: THREE.MOUSE.ROTATE
            };
            orbitControls.enableZoom = false;
            orbitControls.update();

            // UI Panel
            uiPanel = document.createElement('div');
            uiPanel.id = 'ui-panel';
            uiPanel.style.position = 'absolute';
            uiPanel.style.top = '0';
            uiPanel.style.left = '0';
            uiPanel.style.width = '200px';
            uiPanel.style.backgroundColor = '#333';
            uiPanel.style.color = '#fff';
            uiPanel.style.padding = '10px';
            uiPanel.style.zIndex = '10';
            uiPanel.style.overflowY = 'auto';
            uiPanel.style.maxHeight = '100vh';
            uiPanel.style.borderRadius = '0';
            uiPanel.style.display = 'block';
            document.body.appendChild(uiPanel);

            uiPanel.addEventListener('wheel', (e) => e.preventDefault(), { passive: false });

            // Toggle button
            toggleBtn = document.createElement('button');
            toggleBtn.textContent = 'Hide Settings';
            toggleBtn.style.position = 'absolute';
            toggleBtn.style.top = '10px';
            toggleBtn.style.left = '10px';
            toggleBtn.style.backgroundColor = '#555';
            toggleBtn.style.border = 'none';
            toggleBtn.style.color = '#fff';
            toggleBtn.style.padding = '5px 10px';
            toggleBtn.style.cursor = 'pointer';
            toggleBtn.style.borderRadius = '0';
            toggleBtn.style.zIndex = '11';
            toggleBtn.onclick = () => {
                uiPanel.style.display = uiPanel.style.display === 'none' ? 'block' : 'none';
                toggleBtn.textContent = uiPanel.style.display === 'none' ? 'Show Settings' : 'Hide Settings';
            };
            document.body.appendChild(toggleBtn);

            // Create slider function
            function createSlider(labelText, id, min, max, step, value, onChange) {
                const div = document.createElement('div');
                div.style.marginBottom = '15px';

                const label = document.createElement('label');
                label.textContent = labelText;
                label.htmlFor = id;
                label.style.display = 'block';
                label.style.marginBottom = '5px';

                const slider = document.createElement('input');
                slider.type = 'range';
                slider.id = id;
                slider.min = min;
                slider.max = max;
                slider.step = step;
                slider.value = value;
                slider.style.width = '100%';
                slider.oninput = (e) => {
                    onChange(e);
                    valueDisplay.textContent = parseFloat(e.target.value).toFixed(id === 'player-speed' || id === 'skill-speed' || id === 'render-distance' || id === 'cam-fov' ? 0 : 2);
                };

                const valueDisplay = document.createElement('span');
                valueDisplay.id = id + '-value';
                valueDisplay.textContent = parseFloat(value).toFixed(id === 'player-speed' || id === 'skill-speed' || id === 'render-distance' || id === 'cam-fov' ? 0 : 2);
                valueDisplay.style.marginLeft = '10px';

                const sliderContainer = document.createElement('div');
                sliderContainer.style.display = 'flex';
                sliderContainer.style.alignItems = 'center';
                sliderContainer.appendChild(slider);
                sliderContainer.appendChild(valueDisplay);

                div.appendChild(label);
                div.appendChild(sliderContainer);
                return div;
            }

            // Player Section
            const playerSection = document.createElement('div');
            playerSection.className = 'ui-section';
            playerSection.innerHTML = '<h3>Player</h3>';
            playerSection.appendChild(createSlider('Player Speed', 'player-speed', 80, 200, 1, settings.moveSpeed, (e) => {
                settings.moveSpeed = parseFloat(e.target.value);
            }));
            playerSection.appendChild(createSlider('Skill Speed', 'skill-speed', 80, 400, 1, skillSpeed, (e) => {
                skillSpeed = parseFloat(e.target.value);
            }));
            uiPanel.appendChild(playerSection);

            // Camera Section
            const cameraSection = document.createElement('div');
            cameraSection.className = 'ui-section';
            cameraSection.innerHTML = '<h3>Camera</h3>';
            cameraSection.appendChild(createSlider('Camera Distance', 'cam-dist', 10, 50, 0.1, cameraDistance, (e) => {
                cameraDistance = parseFloat(e.target.value);
                updateCameraPosition();
            }));
            cameraSection.appendChild(createSlider('Camera FOV', 'cam-fov', 30, 120, 1, cameraFov, (e) => {
                cameraFov = parseFloat(e.target.value);
                camera.fov = cameraFov;
                camera.updateProjectionMatrix();
            }));
            uiPanel.appendChild(cameraSection);

            // Area Section
            const areaSection = document.createElement('div');
            areaSection.className = 'ui-section';
            areaSection.innerHTML = '<h3>Area</h3>';
            areaSection.appendChild(createSlider('Circle Radius', 'circle-radius', 10, 100, 1, settings.circleRadius, (e) => {
                settings.circleRadius = parseFloat(e.target.value);
                const newGeometry = new THREE.CircleGeometry(settings.circleRadius, 32);
                floor.geometry.dispose();
                floor.geometry = newGeometry;
                scene.children.forEach(child => {
                    if (child.isLine && child.geometry.attributes.position) {
                        child.geometry.dispose();
                        scene.remove(child);
                    }
                });
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
                for (let i = 0; i < 8; i++) {
                    const angle = (i * Math.PI / 4) + (Math.PI / 8);
                    const points = [
                        new THREE.Vector3(0, 0.01, 0),
                        new THREE.Vector3(Math.cos(angle) * settings.circleRadius, 0.01, Math.sin(angle) * settings.circleRadius)
                    ];
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(geometry, lineMaterial);
                    scene.add(line);
                }
                northCylinder.position.set(0, 1, settings.circleRadius + 0.5);
                eastCylinder.position.set(settings.circleRadius + 0.5, 1, 0);
                southCylinder.position.set(0, 1, -(settings.circleRadius + 0.5));
                westCylinder.position.set(-(settings.circleRadius + 0.5), 1, 0);
                updateShadowCamera();
            }));
            areaSection.appendChild(createSlider('Skill Circle Size', 'skill-radius', 1, 10, 0.5, skillRadius, (e) => {
                skillRadius = parseFloat(e.target.value);
                const newSkillGeometry = new THREE.CircleGeometry(skillRadius, 32);
                skillCircle.geometry.dispose();
                skillCircle.geometry = newSkillGeometry;
            }));
            uiPanel.appendChild(areaSection);

            // Debug Section
            const debugSection = document.createElement('div');
            debugSection.className = 'ui-section';
            debugSection.innerHTML = '<h3>Debug</h3>';
            debugSection.appendChild(createSlider('Render Distance', 'render-distance', 10, 500, 1, renderDistance, (e) => {
                renderDistance = parseFloat(e.target.value);
                camera.far = renderDistance;
                camera.updateProjectionMatrix();
            }));
            uiPanel.appendChild(debugSection);

            // Save button
            const saveBtn = document.createElement('button');
            saveBtn.textContent = 'Save Settings';
            saveBtn.style.width = '100%';
            saveBtn.style.backgroundColor = '#4CAF50';
            saveBtn.style.border = 'none';
            saveBtn.style.color = '#fff';
            saveBtn.style.padding = '5px';
            saveBtn.style.marginBottom = '5px';
            saveBtn.style.cursor = 'pointer';
            saveBtn.style.borderRadius = '0';
            saveBtn.onclick = () => {
                const savedSettings = {
                    moveSpeed: settings.moveSpeed,
                    skillSpeed: skillSpeed,
                    skillRadius: skillRadius,
                    cameraDistance: cameraDistance,
                    cameraFov: cameraFov,
                    circleRadius: settings.circleRadius,
                    renderDistance: renderDistance
                };
                localStorage.setItem('gameSettings', JSON.stringify(savedSettings));
            };
            uiPanel.appendChild(saveBtn);

            // Reset button
            const resetBtn = document.createElement('button');
            resetBtn.textContent = 'Reset Settings';
            resetBtn.style.width = '100%';
            resetBtn.style.backgroundColor = '#f44336';
            resetBtn.style.border = 'none';
            resetBtn.style.color = '#fff';
            resetBtn.style.padding = '5px';
            resetBtn.style.cursor = 'pointer';
            resetBtn.style.borderRadius = '0';
            resetBtn.onclick = () => {
                settings.moveSpeed = defaults.moveSpeed;
                skillSpeed = defaults.skillSpeed;
                skillRadius = defaults.skillRadius;
                cameraDistance = defaults.cameraDistance;
                cameraFov = defaults.cameraFov;
                settings.circleRadius = defaults.circleRadius;
                renderDistance = defaults.renderDistance;

                document.getElementById('player-speed').value = settings.moveSpeed;
                document.getElementById('player-speed-value').textContent = settings.moveSpeed.toFixed(0);
                document.getElementById('skill-speed').value = skillSpeed;
                document.getElementById('skill-speed-value').textContent = skillSpeed.toFixed(0);
                document.getElementById('skill-radius').value = skillRadius;
                document.getElementById('skill-radius-value').textContent = skillRadius.toFixed(2);
                document.getElementById('cam-dist').value = cameraDistance;
                document.getElementById('cam-dist-value').textContent = cameraDistance.toFixed(2);
                document.getElementById('cam-fov').value = cameraFov;
                document.getElementById('cam-fov-value').textContent = cameraFov.toFixed(0);
                document.getElementById('circle-radius').value = settings.circleRadius;
                document.getElementById('circle-radius-value').textContent = settings.circleRadius.toFixed(0);
                document.getElementById('render-distance').value = renderDistance;
                document.getElementById('render-distance-value').textContent = renderDistance.toFixed(0);

                const newGeometry = new THREE.CircleGeometry(settings.circleRadius, 32);
                floor.geometry.dispose();
                floor.geometry = newGeometry;
                scene.children.forEach(child => {
                    if (child.isLine && child.geometry.attributes.position) {
                        child.geometry.dispose();
                        scene.remove(child);
                    }
                });
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
                for (let i = 0; i < 8; i++) {
                    const angle = (i * Math.PI / 4) + (Math.PI / 8);
                    const points = [
                        new THREE.Vector3(0, 0.01, 0),
                        new THREE.Vector3(Math.cos(angle) * settings.circleRadius, 0.01, Math.sin(angle) * settings.circleRadius)
                    ];
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(geometry, lineMaterial);
                    scene.add(line);
                }
                northCylinder.position.set(0, 1, settings.circleRadius + 0.5);
                eastCylinder.position.set(settings.circleRadius + 0.5, 1, 0);
                southCylinder.position.set(0, 1, -(settings.circleRadius + 0.5));
                westCylinder.position.set(-(settings.circleRadius + 0.5), 1, 0);
                const newSkillGeometry = new THREE.CircleGeometry(skillRadius, 32);
                skillCircle.geometry.dispose();
                skillCircle.geometry = newSkillGeometry;
                camera.fov = cameraFov;
                camera.far = renderDistance;
                camera.updateProjectionMatrix();
                updateShadowCamera();

                updateCameraPosition();
            };
            uiPanel.appendChild(resetBtn);

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('wheel', onWheel);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            window.addEventListener('mousedown', onMouseDown);

            updateCameraPosition();
        }

        function updateShadowCamera() {
            const shadowSize = settings.circleRadius * 1.2; // 20% larger than circle to ensure coverage
            dirLight.shadow.camera.top = shadowSize;
            dirLight.shadow.camera.right = shadowSize;
            dirLight.shadow.camera.bottom = -shadowSize;
            dirLight.shadow.camera.left = -shadowSize;
            dirLight.shadow.camera.near = 0.1;
            dirLight.shadow.camera.far = 50;
            dirLight.shadow.camera.updateProjectionMatrix();
        }

        function onMouseDown(event) {
            if (event.target.closest('#ui-panel')) return;
            if (event.button !== 0) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(floor);

            if (intersects.length > 0) {
                const point = intersects[0].point;
                const distFromCenter = Math.sqrt(point.x ** 2 + point.z ** 2);
                if (distFromCenter > settings.circleRadius - 0.5) return;

                if (isSkillMode && !isSkillMoving) {
                    const distFromPlayer = Math.sqrt((point.x - position.x) ** 2 + (point.z - position.z) ** 2);
                    if (distFromPlayer <= skillRadius) {
                        targetPosition = point.clone();
                        targetPosition.y = 1;
                        isSkillMoving = true;
                        isSkillMode = false;
                        skillCircle.visible = false;
                        currentMoveSpeed = skillSpeed / 10; // Adjusted for slower movement
                    }
                } else if (!isSkillMoving) {
                    targetPosition = point.clone();
                    targetPosition.y = 1;
                    currentMoveSpeed = settings.moveSpeed / 10; // Adjusted for slower movement
                }
            }
        }

        function onKeyDown(event) {
            const key = event.key.toLowerCase();
            if (['w', 'a', 's', 'd'].includes(key)) {
                if (!isSkillMoving && !isSkillMode) {
                    keys[key] = true;
                    targetPosition = null;
                }
            }
            if (key === '1' && !keys['1'] && !isSkillMoving) {
                keys['1'] = true;
                isSkillMode = !isSkillMode;
                skillCircle.visible = isSkillMode;
                if (isSkillMode) {
                    targetPosition = null;
                    keys.w = keys.a = keys.s = keys.d = false;
                }
            }
        }

        function onKeyUp(event) {
            const key = event.key.toLowerCase();
            if (['w', 'a', 's', 'd'].includes(key)) keys[key] = false;
            if (key === '1') keys['1'] = false;
        }

        function restrictPlayerToCircle() {
            const distance = Math.sqrt(position.x * position.x + position.z * position.z);
            if (distance > settings.circleRadius - 0.5) {
                const scale = (settings.circleRadius - 0.5) / distance;
                const oldX = position.x;
                const oldZ = position.z;
                position.x *= scale;
                position.z *= scale;
                position.y = 1;
                camera.position.x += (position.x - oldX);
                camera.position.z += (position.z - oldZ);
                playerGroup.position.copy(position);
                if (isSkillMoving) {
                    targetPosition = null;
                    isSkillMoving = false;
                }
            }
        }

        function updateCameraPosition() {
            const playerPos = position.clone();
            const direction = camera.position.clone().sub(playerPos).normalize();
            const newPos = playerPos.clone().add(direction.multiplyScalar(cameraDistance));
            camera.position.copy(newPos);
            orbitControls.target.copy(playerPos);
            orbitControls.update();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onWheel(e) {
            if (e.target.closest('#ui-panel')) return;
            const delta = e.deltaY > 0 ? 0.2 : -0.2;
            cameraDistance = Math.max(10, Math.min(50, cameraDistance + delta));
            updateCameraPosition();
            const camSlider = document.getElementById('cam-dist');
            if (camSlider) {
                camSlider.value = cameraDistance;
                document.getElementById('cam-dist-value').textContent = cameraDistance.toFixed(2);
            }
        }

        function updateCharacter(delta) {
            const azimuth = orbitControls.getAzimuthalAngle();

            // Click-to-move or skill movement
            if (targetPosition && (!isSkillMoving || currentMoveSpeed === skillSpeed / 10)) {
                const moveSpeed = currentMoveSpeed * delta; // Apply delta for frame-rate independence
                const direction = targetPosition.clone().sub(position).normalize();
                const step = direction.clone().multiplyScalar(moveSpeed);
                const oldX = position.x;
                const oldZ = position.z;
                if (step.length() >= position.distanceTo(targetPosition)) {
                    position.x = targetPosition.x;
                    position.z = targetPosition.z;
                    position.y = 1;
                    camera.position.x += targetPosition.x - oldX;
                    camera.position.z += targetPosition.z - oldZ;
                    playerGroup.position.copy(position);
                    targetPosition = null;
                    isSkillMoving = false;
                } else {
                    position.x += step.x;
                    position.z += step.z;
                    position.y = 1;
                    camera.position.x += step.x;
                    camera.position.z += step.z;
                    playerGroup.position.copy(position);
                }
                restrictPlayerToCircle();
                orbitControls.target.copy(position);
                orbitControls.update();
                return;
            }

            // WASD movement
            if (!isSkillMoving && !isSkillMode) {
                let forward = 0;
                if (keys.w) forward = -1;
                if (keys.s) forward = 1;
                let strafe = 0;
                if (keys.a) strafe = -1;
                if (keys.d) strafe = 1;

                if (forward !== 0 || strafe !== 0) {
                    ease.set(strafe, 0, forward).multiplyScalar((settings.moveSpeed / 10) * delta);
                    const angle = Math.atan2(ease.x, ease.z) + azimuth;
                    rotate.setFromAxisAngle(up, angle);
                    ease.applyAxisAngle(up, azimuth);
                    const oldX = position.x;
                    const oldZ = position.z;
                    position.x += ease.x;
                    position.z += ease.z;
                    position.y = 1;
                    camera.position.x += ease.x;
                    camera.position.z += ease.z;
                    playerGroup.position.copy(position);
                    playerGroup.quaternion.rotateTowards(rotate, settings.rotateSpeed);
                    restrictPlayerToCircle();
                    orbitControls.target.copy(position);
                    orbitControls.update();
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            if (isSkillMode) {
                skillCircle.position.x = position.x;
                skillCircle.position.z = position.z;
            }
            updateCharacter(delta);
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>