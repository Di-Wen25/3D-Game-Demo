<!DOCTYPE html>
<html lang="en">
<head>
    <title>3d Demo</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
    <style>
        a {
            color: #f00;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="info">
        <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - Simple Walking Demo<br/>
        Use W,A,S,D to move, right-click drag to rotate camera, mouse wheel to zoom
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.167.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.167.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, renderer, camera, floor, player, controls;
        let cameraDistance = 5;
        let azimuthalAngle = Math.PI / 4;
        let polarAngle = Math.PI / 4;
        const minDistance = 2;
        const maxDistance = 15;
        const maxPolarAngle = Math.PI / 2 - 0.01;
        const moveSpeed = 0.1;
        const keys = { w: false, a: false, s: false, d: false };

        init();
        animate();

        function init() {
            const container = document.getElementById('container');

            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x5e5d5d);

            // Camera setup
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 2, -5);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(-2, 5, -3);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = dirLight.shadow.camera.right = 2;
            dirLight.shadow.camera.bottom = dirLight.shadow.camera.left = -2;
            dirLight.shadow.camera.near = 3;
            dirLight.shadow.camera.far = 8;
            dirLight.shadow.mapSize.set(1024, 1024);
            scene.add(dirLight);
            scene.add(dirLight.target);

            // Floor (circular with grid)
            const floorGeometry = new THREE.CircleGeometry(20, 32);
            const floorMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, side: THREE.DoubleSide });
            floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Circular grid on floor
            const gridTexture = new THREE.GridHelper(40, 40, 0x000000, 0x000000);
            gridTexture.position.y = 0.01;
            scene.add(gridTexture);

            // Player (green sphere)
            const playerGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            const playerMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
            player = new THREE.Mesh(playerGeometry, playerMaterial);
            player.position.y = 0.5;
            player.castShadow = true;
            scene.add(player);

            // OrbitControls for right-click rotation
            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.copy(player.position);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.mouseButtons = {
                LEFT: null,
                MIDDLE: null,
                RIGHT: THREE.MOUSE.ROTATE
            };
            controls.enableZoom = false;
            controls.enablePan = false;
            controls.maxPolarAngle = maxPolarAngle;

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('wheel', onWheel);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            // Initial camera position
            updateCameraPosition();
        }

        function updateCameraPosition() {
            // Clamp polar angle
            polarAngle = Math.max(0, Math.min(maxPolarAngle, polarAngle));

            // Convert spherical to Cartesian
            const sinPolar = Math.sin(polarAngle);
            const cosPolar = Math.cos(polarAngle);
            const sinAzimuth = Math.sin(azimuthalAngle);
            const cosAzimuth = Math.cos(azimuthalAngle);

            const offset = new THREE.Vector3(
                cameraDistance * sinPolar * cosAzimuth,
                cameraDistance * cosPolar,
                cameraDistance * sinPolar * sinAzimuth
            );

            camera.position.copy(player.position).add(offset);
            camera.lookAt(player.position);
            controls.target.copy(player.position);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onWheel(e) {
            const delta = e.deltaY > 0 ? 0.2 : -0.2;
            cameraDistance = Math.max(minDistance, Math.min(maxDistance, cameraDistance + delta));
            updateCameraPosition();
        }

        function onKeyDown(event) {
            const key = event.key.toLowerCase();
            if (['w', 'a', 's', 'd'].includes(key)) keys[key] = true;
        }

        function onKeyUp(event) {
            const key = event.key.toLowerCase();
            if (['w', 'a', 's', 'd'].includes(key)) keys[key] = false;
        }

        function animate() {
            requestAnimationFrame(animate);

            // Store previous angles
            const prevAzimuthalAngle = azimuthalAngle;
            const prevPolarAngle = polarAngle;

            // Update angles from OrbitControls
            controls.update();
            const deltaX = camera.position.x - player.position.x;
            const deltaZ = camera.position.z - player.position.z;
            const deltaY = camera.position.y - player.position.y;
            const horizontalDistance = Math.sqrt(deltaX * deltaX + deltaZ * deltaZ);
            azimuthalAngle = Math.atan2(deltaZ, deltaX);
            polarAngle = Math.atan2(horizontalDistance, deltaY);

            // Update camera position only if angles changed significantly
            if (Math.abs(azimuthalAngle - prevAzimuthalAngle) > 0.0001 ||
                Math.abs(polarAngle - prevPolarAngle) > 0.0001) {
                updateCameraPosition();
            }

            // Player movement
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);
            cameraDirection.y = 0;
            cameraDirection.normalize();

            const rightVector = new THREE.Vector3();
            rightVector.crossVectors(cameraDirection, new THREE.Vector3(0, 1, 0)).normalize();

            const moveVector = new THREE.Vector3(0, 0, 0);
            if (keys.w) moveVector.add(cameraDirection);
            if (keys.s) moveVector.sub(cameraDirection);
            if (keys.a) moveVector.sub(rightVector);
            if (keys.d) moveVector.add(rightVector);

            if (moveVector.lengthSq() > 0) {
                moveVector.normalize().multiplyScalar(moveSpeed);
                player.position.add(moveVector);
                updateCameraPosition();
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>